
 4.4.3 Python:                                             *UltiSnips-python*

Python interpolation is by far the most powerful. The syntax is similar to Vim
scripts except code is started with '!p'. Python scripts can be run using the
python shebang '#!/usr/bin/python', but using the '!p' format comes with some
predefined objects and variables, which can simplify and shorten code. For
example, a 'snip' object instance is implied in python code. Python code using
the '!p' indicator differs also in another way. Generally when a snippet is
expanded the standard output of code replaces the code. With python code the
value of the 'snip.rv' property replaces the code. Standard output is ignored.

The variables automatically defined in python code are: >

   fn      - The current filename
   path    - The complete path to the current file
   t       - The values of the placeholders, t[1] is the text of ${1}, etc.
   snip    - UltiSnips.TextObjects.SnippetUtil object instance. Has methods
             that simplify indentation handling and owns the string that
             should be inserted for the snippet.
   context - Result of context condition. See |UltiSnips-custom-context-snippets|.
   match   - Only in regular expression triggered snippets. This is the return
             value of the match of the regular expression. See
             http://docs.python.org/library/re.html#match-objects

The 'snip' object provides the following methods: >

    snip.mkline(line="", indent=None):
        Returns a line ready to be appended to the result. If indent
        is None, then mkline prepends spaces and/or tabs appropriate to the
        current 'tabstop' and 'expandtab' variables.

    snip.shift(amount=1):
        Shifts the default indentation level used by mkline right by the
        number of spaces defined by 'shiftwidth', 'amount' times.

    snip.unshift(amount=1):
        Shifts the default indentation level used by mkline left by the
        number of spaces defined by 'shiftwidth', 'amount' times.

    snip.reset_indent():
        Resets the indentation level to its initial value.

    snip.opt(var, default):
        Checks if the Vim variable 'var' has been set. If so, it returns the
        variable's value; otherwise, it returns the value of 'default'.

The 'snip' object provides some properties as well: >

    snip.rv:
        'rv' is the return value, the text that will replace the python block
        in the snippet definition. It is initialized to the empty string. This
        deprecates the 'res' variable.

    snip.c:
        The text currently in the python block's position within the snippet.
        It is set to empty string as soon as interpolation is completed. Thus
        you can check if snip.c is != "" to make sure that the interpolation
        is only done once. This deprecates the "cur" variable.

    snip.v:
         Data related to the ${VISUAL} placeholder. This has two attributes:
             snip.v.mode   ('v', 'V', '^V', see |visual-mode| )
             snip.v.text   The text that was selected.

    snip.fn:
        The current filename.

    snip.basename:
        The current filename with the extension removed.

    snip.ft:
        The current filetype.

    snip.p:
        Last selected placeholder. Will contain placeholder object with
        following properties:

        'current_text' - text in the placeholder on the moment of selection;
        'start' - placeholder start on the moment of selection;
        'end' - placeholder end on the moment of selection;

For your convenience, the 'snip' object also provides the following
operators: >

    snip >> amount:
        Equivalent to snip.shift(amount)
    snip << amount:
        Equivalent to snip.unshift(amount)
    snip += line:
        Equivalent to "snip.rv += '\n' + snip.mkline(line)"

Any variables defined in a python block can be used in other python blocks
that follow within the same snippet. Also, the python modules 'vim', 're',
'os', 'string' and 'random' are pre-imported within the scope of snippet code.
Other modules can be imported using the python 'import' command.

Python code allows for very flexible snippets. For example, the following
snippet mirrors the first tabstop value on the same line but right aligned and
in uppercase.

------------------- SNIP -------------------
>
    snippet wow
    ${1:Text}`!p snip.rv = (75-2*len(t[1]))*' '+t[1].upper()`
    endsnippet
<
------------------- SNAP -------------------
wow<tab>Hello World ->
Hello World                                                     HELLO WORLD

The following snippet uses the regular expression option and illustrates
regular expression grouping using python's match object. It shows that the
expansion of a snippet can depend on the tab trigger used to define the
snippet, and that tab trigger itself can vary.

------------------- SNIP -------------------
>
    snippet "be(gin)?( (\S+))?" "begin{} / end{}" br
    \begin{${1:`!p
    snip.rv = match.group(3) if match.group(2) is not None else "something"`}}
        ${2:${VISUAL}}
    \end{$1}$0
    endsnippet
<
------------------- SNAP -------------------
be<tab>center<c-j> ->
\begin{center}

\end{center}
------------------- SNAP -------------------
be center<tab> ->
\begin{center}

\end{center}

The second form is a variation of the first; both produce the same result,
but it illustrates how regular expression grouping works. Using regular
expressions in this manner has some drawbacks:
1. If you use the <Tab> key for both expanding snippets and completion then
   if you typed "be form<Tab>" expecting the completion "be formatted", you
   would end up with the above SNAP instead, not what you want.
2. The snippet is harder to read.

The biggest advantage, however, is that you can create snippets that take into
account the text preceding a "trigger". This way, you can use it to create
postfix snippets, which are popular in some IDEs.

------------------- SNIP -------------------
>
    snippet "(\w+).par" "Parenthesis (postfix)" r
    (`!p snip.rv = match.group(1)`$1)$0
    endsnippet
<
------------------- SNAP -------------------
something.par<tab> ->
(something)

------------------- SNIP -------------------
>
    snippet "([^\s].*)\.return" "Return (postfix)" r
    return `!p snip.rv = match.group(1)`$0
    endsnippet
<
------------------- SNAP -------------------
value.return<tab> ->
return value


 4.4.4 Global Snippets:                                   *UltiSnips-globals*
